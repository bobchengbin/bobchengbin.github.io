<!doctype html>
<html lang="en"> <head> <title>Du, Chengbin&#039;s Blog</title> <meta http-equiv="content-type" content="text/html;" charset="UTF-8" /> <meta name="viewport" content="width=device-width, initial-scale=1"> <link href="//fonts.googleapis.com/css?family=Vollkorn:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css" /> <link href="//fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css" /> <link href= "https://dcb9.github.io/css/style.css" rel="stylesheet" type="text/css" /> <link rel="alternate" href="https://dcb9.github.io/rss.xml" type="application/rss+xml" />  </head> <body> <div class="navigation"> <a href="https://dcb9.github.io">Du, Chengbin&#039;s Blog</a> | <a href="/">Home</a>  | <a href="http://github.com/dcb9">GitHub</a>  | <a href="https://twitter.com/robertduu">Twitter</a>  </div> <div id="content"> <div class="article-meta">
<h1 class="title">使用 Yii2 时遇到的实际问题</h1>
<div class="tags">
Tagged as <a href="https://dcb9.github.io/tag/Yii2.html">Yii2</a> </div>
<div class="date">
Written on 2014-11-17 </div>
</div>
<div class="article-content">
<p>最近一直在学习 Yii2 框架，可能是一直以来对它的青睐，让我难以对其它框架再产生兴趣，学习中遇到了许多问题，于是把问题和解决办法也记录下来，这样方便以后复习和交流。</p>

<h2><span id="menu"><a href="#menu">目录</a></span></h2>

<p><a href="{{page.url}}#response_xml">扩展 XmlResponseFormatter</a><br />
<a href="{{page.url}}#create_new_app">在原有的 Yii2 框架上，新建一个 api 应用</a><br />
<a href="{{page.url}}#config_request_parser">配置 Yii2 request Parser 使之可以通过 Yii::$app-&gt;request-&gt;post() 来接收 xml 和 json 的数据</a><br />
<a href="{{page.url}}#use_timestamp_behavior">使用 TimestampBehavior 来自动填充 created_at 和 updated_at </a></p>

<h2><span id="response_xml"><a href="#response_xml">扩展 XmlResponseFormatter</a></span></h2>

<p>在做微信接口测试的时候发现，每次返回数据的时候都是自己写的 xml 信息然后 echo 出来，今天突然看到了 <code>Yii::$app-&gt;response-&gt;format = Response::FORMAT_XML;</code> 原来通过这个就可以设置返回的数据为 xml ，当然 <code>response</code> 这个类在 Controller 里面是没有加载的，所以首先得加载一下 <code>use yii\web\Response;</code> ，最后把需要返回的数据用数组的形式来返回即可：</p>

<pre><code>&lt;?php 
// ... ...
use yii\web\Response;

public function actionIndex(){
    // ... ... 原来的逻辑代码
    Yii::$app-&gt;response-&gt;format = Response::FORMAT_XML;
    return [
            &quot;ToUserName&quot;=&gt;$postObject-&gt;FromUserName,
            &quot;FromUserName&quot;=&gt;$postObject-&gt;ToUserName,
            &quot;CreateTime&quot;=&gt;time(),
            &quot;MsgType&quot;=&gt;&quot;music&quot;,
            &quot;Music&quot;=&gt;[
                &quot;Title&quot;=&gt;$recognition,
                &quot;Description&quot;=&gt;$decode,
                &quot;MusicUrl&quot;=&gt;$musicurl,
                &quot;HQMusicUrl&quot;=&gt;$musicurl,
            ]
        ];
}
</code></pre>

<p>这样使用之后发现请求得到的结果是：</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;response&gt;
    &lt;ToUserName&gt;&lt;SimpleXMLElement&gt;&lt;FromUserName&gt;&lt;SimpleXMLElement/&gt;&lt;/FromUserName&gt;&lt;/SimpleXMLElement&gt;&lt;/ToUserName&gt;
    &lt;FromUserName&gt;&lt;SimpleXMLElement&gt;&lt;ToUserName&gt;&lt;SimpleXMLElement/&gt;&lt;/ToUserName&gt;&lt;/SimpleXMLElement&gt;&lt;/FromUserName&gt;
    &lt;CreateTime&gt;1416207112&lt;/CreateTime&gt;
    &lt;MsgType&gt;music&lt;/MsgType&gt;
    &lt;Music&gt;
        &lt;Title&gt;maps maroon5&lt;/Title&gt;
        &lt;Description&gt;120976464.mp3?xcode=7ba3137f5fd742bcba7a6f5a2ffb7764172503013bacbdc8&lt;/Description&gt;
        &lt;MusicUrl&gt;http://zhangmenshiting.baidu.com/data2/music/120976464/120976464.mp3?xcode=7ba3137f5fd742bcba7a6f5a2ffb7764172503013bacbdc8&lt;/MusicUrl&gt;
        &lt;HQMusicUrl&gt;http://zhangmenshiting.baidu.com/data2/music/120976464/120976464.mp3?xcode=7ba3137f5fd742bcba7a6f5a2ffb7764172503013bacbdc8&lt;/HQMusicUrl&gt;
    &lt;/Music&gt;
&lt;/response&gt;
</code></pre>

<p>问题就来了，微信需要的格式是前外层以 <code>&lt;xml&gt;...&lt;/xml&gt;</code> 来定义的，后来终于在 Response 里面的 <code>formatters</code> 发现了信息，它里面定义了每个类相应的信息，我们可以通过手动指定一些信息来覆盖掉系统默认的。</p>

<pre><code>Yii::$app-&gt;response-&gt;formatters = [Response::FORMAT_XML=&gt; ['class'=&gt;yii\web\XmlResponseFormatter'， 'rootTag'=&gt;'xml'];
</code></pre>

<p>通过这样设置之后，最外层的 response 终于变成了 xml，又发现了一个问题，那就是我的内容里面根本就没有<code>SimpleXMLElement</code>相关的东西，这个怎么会多出来？回看了一下逻辑代码发现有：</p>

<pre><code>$postObject = simplexml_load_string($postStr, 'SimpleXMLElement', LIBXML_NOCDATA);
</code></pre>

<p>最后只能在return的时候加上类型转换为字符串，这下终于恢复正常了。</p>

<pre><code>return [
    &quot;ToUserName&quot;=&gt;(string)$postObject-&gt;FromUserName,
    &quot;FromUserName&quot;=&gt;(string)$postObject-&gt;ToUserName,
    // ...
]
</code></pre>

<p>在使用这个的时候有的数据是需要加上 CDataSection(<code>&lt;![CDATA[ ... ]]&gt;</code>) 的，因为不然如果内容里面带有了 <code>&lt;</code> 这种就会出问题。这个确实让我头疼了很久，首先看了一下源代码原来的类 <code>XmlResponseFormatter</code>， 确实无法满足相应的需求，满足不了需求就只能扩展了</p>

<p>step1. 在应用下创建一个 component 目录
step2. 在component目录下新建一个 MyXmlResponseFormatter.php 的文件
step3. 实现这个类</p>

<pre><code>&lt;?php

namespace weixin\component;

use yii\web\XmlResponseFormatter;
use DOMElement;
use DOMText;
use yii\helpers\StringHelper;
use yii\base\Arrayable;
use DOMCdataSection;

class MyXmlResponseFormatter extends XmlResponseFormatter{
    public $rootTag = &quot;xml&quot;;  // 这里我就可以把 rootTag 的默认值修改成 xml 了
    /**
     * 如果需要使用 CDATA 那就需要把原来的数据转成数组，并且数组含有以下key
     * ，我们就把这个节点添加成一个 DOMCdataSection 
     */
    const CDATA = '---cdata---';  // 这个是是否使用CDATA 的下标
     /**
     * @param DOMElement $element
     * @param mixed $data
     */
    protected function buildXml($element, $data)
    {
        if (is_object($data)) {
            // 这里保持原来的代码不变
        } elseif (is_array($data)) {
            foreach ($data as $name =&gt; $value) {
                if (is_int($name) &amp;&amp; is_object($value)) {
                    $this-&gt;buildXml($element, $value);
                } elseif (is_array($value) || is_object($value)) {
                    $child = new DOMElement(is_int($name) ? $this-&gt;itemTag : $name);
                    $element-&gt;appendChild($child);
                    // 主要就是修改这一个点，如果值是一个数组，并且含有 CDATA 的，那么就直接创建一个 CdataSection 节点，
                    // 而不把它本身当作列表再回调。
                    if(array_key_exists(self::CDATA, $value)){
                        $child-&gt;appendChild(new DOMCdataSection((string) $value[0]));
                    }else{
                        $this-&gt;buildXml($child, $value);
                    }
                } else {
                    $child = new DOMElement(is_int($name) ? $this-&gt;itemTag : $name);
                    $element-&gt;appendChild($child);
                    $child-&gt;appendChild(new DOMText((string) $value));
                }
            }
        } else {
            $element-&gt;appendChild(new DOMText((string) $data));
        }
    }
}
</code></pre>

<p>step4. 修改默认的 xml 解析所使用的类为新建的扩展类</p>

<pre><code>Yii::$app-&gt;response-&gt;formatters = [
    Response::FORMAT_XML=&gt; ['class'=&gt;'weixin\component\MyXmlResponseFormatter']
];
</code></pre>

<p>step5. 如果说字符串需要使用 CDATA 的时候需要设置</p>

<pre><code>use weixin\component\MyXmlResponseFormatter as MXRF;

return [
    &quot;ToUserName&quot;=&gt;[$postObj-&gt;FromUserName,MXRF::CDATA=&gt;true],
    &quot;FromUserName&quot;=&gt;[$postObj-&gt;ToUserName,MXRF::CDATA=&gt;true],
    &quot;CreateTime&quot;=&gt;time(),
    &quot;MsgType&quot;=&gt;&quot;music&quot;,
    &quot;Music&quot;=&gt;[
        &quot;Title&quot;=&gt;[$recognition,MXRF::CDATA=&gt;true],
        &quot;Description&quot;=&gt;[$decode,MXRF::CDATA=&gt;true],
        &quot;MusicUrl&quot;=&gt;[$musicurl,MXRF::CDATA=&gt;true],
        &quot;HQMusicUrl&quot;=&gt;[$musicurl,MXRF::CDATA=&gt;true],
    ]
];
</code></pre>

<p>经过本次的修改算是对如何修改和扩展Yii2 有了一定的认识。</p>

<h2><span id="create_new_app"><a href="#create_new_app">在原有的Yii2框架上，新建一个api应用</a></span></h2>

<p>在做东西的时候需要清晰的结构和逻辑，这样做出来的东西相对来说会比较漂亮，所以为了api我们可能得新建一个应用，这里面全是api相关的程序，我通过Google “<code>yii2 create new application</code>”，“<code>yii2 add new application</code>”，都没有找到相要的答案，于是只能开动自己的脑筋了。</p>

<p><code>$ cp -a environments/dev/frontend environments/dev/api</code></p>

<p><code>$ cp -a environments/prod/frontend environments/prod/api</code></p>

<pre><code># file: environments/index.php
&lt;?php
// 这里仅说明了我添加了哪些信息，不需要删除任何信息，只需要添加。
return [
    'Development' =&gt; [
        'setWritable' =&gt; [
            // ... 在原来的后面添加上
            'api/runtime',
            'api/web/assets'
        ],
        'setCookieValidationKey' =&gt; [
            // ... 在原来的后面添加上
            'api/config/main-local.php',
        ],
    ],
    'Production' =&gt; [
        // 这里和上面一样的添加
    ],
];
</code></pre>

<p>创建相应的目录：<br />
<code>$ mkdir -p api/{assets,config,controllers,models,runtime,web/assets}</code><br />
<code>$ touch api/{assets,config,controllers,models,runtime,web/assets}/.gitkeep</code></p>

<p>复制配置文件：<br />
<code>$ cp -a frontend/config/params.php frontend/config/main.php frontend/config/bootstrap.php frontend/config/.gitignore api/config</code>
<br /><code>$ cp frontend/runtime/.gitignore api/runtime/</code>
<br /><code>$ cp frontend/web/.gitignore api/web</code></p>

<pre><code># file api/config/main.php

return [
    'id' =&gt; 'app-api',
    // ... 
    'controllerNamespace' =&gt; 'api\controllers',
]

# file common/config/bootstrap.php
Yii::setAlias('api', dirname(dirname(__DIR__)) . '/api');

// 配置的其它信息看自己的需求而定
</code></pre>

<p><code>$ ./init</code></p>

<p>新建一个Controller来测试一下：</p>

<pre><code># file: api/controllers/SiteController.php
&lt;?php
namespace api\controllers;

use yii\web\Controller;

class SiteController extends Controller {
    public $layout = false;

    public function actionIndex(){
        return &quot;test&quot;;
    }
} 
</code></pre>

<p>然后通过浏览器访问相应的地址 http://hostname/api/web/index.php?r=site/index 能出来 test 则代表 ok 啦，以上步骤都是一步步的尝试和查看源代码得来的，可能会有不规范的地方，若有不对的地方请到 Github （<a href="https://github.com/dcb9/dcb9.github.io/blob/master/_posts/2014-11-17-yii2-usage.md" >yii2-usage</a>）上留言。</p>

<h2><span id="config_request_parser"><a href="#config_request_parser">配置Yii2 request Parser使之可以通过Yii::$app-&gt;request-&gt;post()来接收 xml 和 json的数据</a></span></h2>

<p>大家都知道 <code>Yii2</code> 接收 <code>POST</code> 数据是使用 <code>Yii::$app-&gt;request-&gt;post();</code>，但是如果发送过来的数据格式是 <code>json</code> 或 <code>xml</code> 的时候，通过这个方法就无法获取到数据了，<code>Yii2</code> 这么强大的组件型框架肯定想到了这一点。</p>

<p>对于 <code>json</code> 的解析 <code>Yii2</code> 已经写好了 [[JsonResponseFormatter]] ，在配置文件里面配置一下即可使用。</p>

<pre><code># file app/config/main.php

'components' =&gt;[
    'request' =&gt; [
        'parsers' =&gt; [
            'application/json' =&gt; 'yii\web\JsonParser',
            'text/json' =&gt; 'yii\web\JsonParser',
        ],
    ],
],
</code></pre>

<p>配置好之后访问提交过来的数据就太简单啦 </p>

<pre><code># json raw data
{&quot;username&quot;: &quot;bob&quot;}

# access data
$post_data = Yii::$app-&gt;request-&gt;post();
echo $post_data[&quot;username&quot;];

# or 
echo Yii::$app-&gt;request-&gt;post(&quot;username&quot;);
</code></pre>

<p>通过框架找到了 JsonParser 所在的目录发现了一个接口 [[RequestParserInterface]] ，并在 JsonParser 的同级目录下未找到 XmlParser 的类，基于 Yii2 组件框架，于是自己来写一个 Parser 用来解析 xml 数据，只需要实现接口提供的方法即可 [[RequestParserInterface::parse()]] ，这里最主要的是将 xml 的数据转换成数组的一个过程，通过 Google 找了很多 &quot;xml to array&quot;，大部分的解析结果我并不满意，要么是功能不完整，要么就是结果不准确，但最终我还是找到了比较完善的 &quot;xml to array&quot; 的类 <a href="http://www.bin-co.com/php/scripts/xml2array/" >xml2array</a>，创建一个类，实现 xml2array 的功能。</p>

<pre><code># file: common/tools/Xml2Array.php  目录不存在的话需要创建

&lt;?php
namespace common\tools;

class Xml2Array
{
    // 把那个网站上的方法复制过来，并在方法前面加上 public static 把方法名换成 go 
    // 注释部分建议也复制过来，这对以后追溯代码的出处很有用。
    // 替换之后的基本格式为：
    public static function go($contents, $get_attributes=1, $priority = 'tag')
    {
        ... ... 
    }
}


# file common/components/XmlRequestParser.php
namespace common\components;

use yii\web\RequestParserInterface;
use common\tools\Xml2Array;

class XmlRequestParser implements  RequestParserInterface
{

    public function parse($rawBody, $contentType)
    {
        $content = Xml2Array::go($rawBody);

        return array_pop($content);
    }
}

# file app/config/main.php

'components' =&gt;[
    'request' =&gt; [
        'parsers' =&gt; [
            'text/xml' =&gt; 'common\components\XmlRequestParser',
            'application/xml' =&gt; 'common\components\XmlRequestParser',

            'application/json' =&gt; 'yii\web\JsonParser',
            'text/json' =&gt; 'yii\web\JsonParser',
        ],
    ],
],
</code></pre>

<p>经过上面的三步之后，就可以直接访问提交过来的 xml 数据了。</p>

<pre><code># raw data
&lt;xml&gt;&lt;username&gt;&lt;![CDATA[bob]]&gt;&lt;/username&gt;&lt;/xml&gt;

# access data
Yii::$app-&gt;request-&gt;post('username');
</code></pre>

<p>这样不管别人传过来的数据是 html、json、xml 格式都可以非常方便的获取了，在和各种接口打交道的时候用上这个可以方便太多了。</p>

<h2><span id="use_timestamp_behavior"><a href="#use_timestamp_behavior">使用 TimestampBehavior 来自动填充 created_at 和 updated_at 的一个坑</a></span></h2>

<p><code>Yii2</code> 官方默认提供了一个 <code>TimestampBehavior</code> 来方便我们来自动填充 <code>created_at</code> 和 <code>updated_at</code> ，它会自动在你插入新数据的时候帮你填充这两个值为当前时间，当然你也可以设置成别的时间，当你更新数据的时候它会自动把 <code>updated_at</code> 改成最后更新的时间。</p>

<p>我创建了一个 <code>user_weixin</code> 表，然后设置 <code>created_at</code> 和 <code>updated_at</code> 两个字段为 <code>datetime</code> 类型，并在相应的 Model 里面使用上 <code>TimestampBehavior</code></p>

<pre><code># file app/models/UserWeixin.php

&lt;?php
... ... 
use yii\behaviors\TimestampBehavior;

class UserWeixin extends ActiveRecord {

    public function behaviors(){
        return [TimestampBehavior::className()];
    }
}
</code></pre>

<p>然后正常的调用保存数据，发现那两个字段的值均为 '0000-00-00 00:00:00'，看到这个感觉甚是奇怪，去看了一下默认生成的用户模型，<code>common/models/User.php</code>，发现它也没有做其它的别的操作就可以的啊，我这样为什么不行呢，去看了一下表结构，发现系统创建的 <code>user</code> 表的两个字段是使用的 <code>int</code> 类型，而不是 <code>datetime</code>，于是把 <code>user_weixin</code> 表的两个字段也改成了 <code>int</code> 类型，再测试一次发现好了。</p>

<p>不甘心的我去看了一下 <code>TimestampBehavior</code> 类的注释，发现确实没有说明这个问题，<em>所以大家在声明 created_at 和 updated_at 字段类型的时候需要注意一下</em>。</p>
 </div>
<div class="relative-nav">
<a href="https://dcb9.github.io/posts/高可用的-Web-架构.html">Previous</a><br>
<a href="https://dcb9.github.io/posts/加入-iDareX-团队.html">Next</a><br>
</div>
 </div>  <div class="fineprint"> <hr> Unless otherwise credited all material <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US"> <img alt="Creative Commons License" style="border-width:0" src="https://dcb9.github.io/css/cc-by-sa.png" /> </a> by Du, Chengbin <a id="coleslaw-logo" href="https://github.com/redline6561/coleslaw"> <img src="https://dcb9.github.io/css/logo_small.jpg" alt="Coleslaw logo" /> </a> </div> </body> </html>