<!doctype html><html>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge"><title>Docker VS 虚拟机 - Du, Chengbin's Blog</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta itemprop=name content="Docker VS 虚拟机">
<meta itemprop=description content="我听说了 `Docker` 多么令人惊叹，但是它并没有征服我的心，直到我提出一个实际的问题：【如果 Scout 使用 Docker 来部署，它会让我们的部署变得更顺利吗？】"><meta itemprop=datePublished content="2015-03-18T00:00:00+08:00">
<meta itemprop=dateModified content="2015-03-18T00:00:00+08:00">
<meta itemprop=wordCount content="670">
<meta itemprop=keywords content="翻译,Docker,"><meta property="og:title" content="Docker VS 虚拟机">
<meta property="og:description" content="我听说了 `Docker` 多么令人惊叹，但是它并没有征服我的心，直到我提出一个实际的问题：【如果 Scout 使用 Docker 来部署，它会让我们的部署变得更顺利吗？】">
<meta property="og:type" content="article">
<meta property="og:url" content="https://dcb9.github.io/posts/2015-03-18/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2015-03-18T00:00:00+08:00">
<meta property="article:modified_time" content="2015-03-18T00:00:00+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Docker VS 虚拟机">
<meta name=twitter:description content="我听说了 `Docker` 多么令人惊叹，但是它并没有征服我的心，直到我提出一个实际的问题：【如果 Scout 使用 Docker 来部署，它会让我们的部署变得更顺利吗？】">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700" rel=stylesheet type=text/css>
<link rel=stylesheet type=text/css media=screen href=https://dcb9.github.io/css/normalize.css>
<link rel=stylesheet type=text/css media=screen href=https://dcb9.github.io/css/main.css>
<link rel=stylesheet type=text/css href=https://dcb9.github.io/css/katex.min.css>
<link id=dark-scheme rel=stylesheet type=text/css href=https://dcb9.github.io/css/dark.css>
<script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script>
<script src=https://dcb9.github.io/js/main.js></script><script src=https://dcb9.github.io/js/katex.min.js></script><script src=https://dcb9.github.io/js/auto-render.min.js></script><script src=https://dcb9.github.io/js/custom.js></script>
</head>
<body>
<div class="container wrapper">
<div class=header>
<h1 class=site-title><a href=https://dcb9.github.io/>Du, Chengbin's Blog</a></h1>
<div class=site-description><p>Software engineer</p><nav class="nav social">
<ul class=flat><li><a href=https://github.com/dcb9 title=Github><i data-feather=github></i></a></li><li><a href=https://twitter.com/robertduu title=Twitter><i data-feather=twitter></i></a></li><li><a href=/index.xml title=RSS><i data-feather=rss></i></a></li></ul>
</nav>
</div>
<nav class=nav>
<ul class=flat>
<li>
<a href=/>Home</a>
</li>
<li>
<a href=/posts>All posts</a>
</li>
<li>
<a href=/about>About</a>
</li>
<li>
<a href=/tags>Tags</a>
</li>
</ul>
</nav>
</div>
<div class=post>
<div class=post-header>
<div class=meta>
<div class=date>
<span class=day>18</span>
<span class=rest>Mar 2015</span>
</div>
</div>
<div class=matter>
<h1 class=title>Docker VS 虚拟机</h1>
</div>
</div>
<div class=markdown>
<p>本文翻译自：《<a href=http://blog.scoutapp.com/articles/2013/08/28/docker-git-for-deployment>Docker: Git for deployment &ndash; Scout</a>》，个人感觉它的内容和标题不对，所以就没有直译过来，要是我理解错了请帮忙纠正。</p>
<p>我听说了 <code>Docker</code> 多么令人惊叹，但是它并没有征服我的心，直到我提出一个实际的问题：【如果 Scout 使用 Docker 来部署，它会让我们的部署变得更顺利吗？】</p>
<p>以下是三个案例：</p>
<h3 id=高效地模拟线上环境>高效地模拟线上环境</h3>
<p><img src=0.png alt></p>
<p>我们线上有 16 台服务器，如果我尝试在本地使用 <code>VirtualBox</code> 配置每个实例 512 MB内存，那么它将占用我笔记本的两倍内存（说明他笔记本只有 4G 内存），<code>VirtualBox</code> 需要有许多多余的开支来管理每个子操作系统，<code>Docker</code> 在这方面是不一样的——容器共享同一个操作系统，更有可能是同样的二进制包文件和库文件，它可以运行在一台 <code>Docker</code> 主机上运行好几百个容器。</p>
<h4 id=老方法>老方法</h4>
<p>我不能在本地完全地模拟线上环境，让我们来看一下通过 <code>Vagrant</code> 启动一台机器需要花多久：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>$ time vagrant up
Bringing machine &#39;default&#39; up with &#39;virtualbox&#39; provider...
[default] Importing base box &#39;squeeze64-ruby193&#39;...
...
[default] Booting VM...
[default] Waiting for VM to boot. This can take a few minutes.
...

real  1m32.052s
</code></pre></div><p>启动一个镜像需要一分半钟，如果我需要修改一个配置文件并检测是否能够正常工作，那么需要重启镜像，那又是可怕的一分半钟。</p>
<p>如果你配置的有错，那将是一个残忍的惩罚。（每次修改就需要一分半钟才能看到结果）</p>
<p>使用 <code>Docker</code> 后</p>
<p>能想像 <code>Docker</code> 有多轻便吗？当你在 <code>Docker</code> 容器里面运行程序，你甚至可能不会注意到他们不是直接在主机上运行的，在下面的例子中，我从标记的 &ldquo;rails&rdquo; 镜像中启动一个 <code>Docker</code> 容器来运行 Rails 应用（Dockerfile）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>root@precise64:~# docker run rails
2013-08-26 20:21:14,600 CRIT Supervisor running as root (no user in config file)
2013-08-26 20:21:14,603 WARN Included extra file &#34;/srv/docker-rails/Supervisorfile&#34; during parsing
2013-08-26 20:21:14,736 INFO RPC interface &#39;supervisor&#39; initialized
2013-08-26 20:21:14,740 CRIT Server &#39;unix_http_server&#39; running without any HTTP authentication checking
2013-08-26 20:21:14,754 INFO supervisord started with pid 1
2013-08-26 20:21:15,783 INFO spawned: &#39;rails&#39; with pid 10
2013-08-26 20:21:16,841 INFO success: rails entered RUNNING state, process has stayed up for &gt; than 1 seconds (startsecs)
</code></pre></div><p>只需要两秒钟就完成了容器的启动和 supervisor 的启动（用来启动 Rails 应用的管理程序）</p>
<p>总之，<code>Docker</code> 能够让你在测试机上完全地模拟线上环境，它是如此的简单，让我可以真正地进行全站测试了。</p>
<h3 id=更简单快速地创建镜像>更简单快速地创建镜像</h3>
<p><img src=1.png alt></p>
<h4 id=传统方法>传统方法</h4>
<p>如果你用脚本从一个基本的镜像创建一个虚拟机镜像（例如：在 <code>Ubuntu</code> 上创建 <code>Rails stack</code>），若想把这个都做的正确是非常痛苦的，除非你经常的在做这个，看看安装 <code>Ruby</code> 依赖的一些信息吧：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span>$</span> time apt-get install -y -q ruby1.9.1 ruby1.9.1-dev rubygems1.9.1 irb1.9.1 build-essential libopenssl-ruby1.9.1 libssl-dev zlib1g-dev
Reading <span style=color:#00f>package</span> lists...
Building dependency tree...
The following extra packages will be installed:
....
Setting up libalgorithm-merge-perl (0.08-2) ...
Processing triggers <span style=color:#00f>for</span> libc-bin ...
ldconfig deferred processing now taking place

real 1m22.470s
</code></pre></div><p>然后，尝试去安装 <code>NodeJS</code> 的依赖，但是你忘记了添加 Node 到 apt 库中</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span>$</span>apt-get install -y nodejs
...
E: Unable to locate <span style=color:#00f>package</span> nodejs
</code></pre></div><p>等你把这个问题解决了，想在新的基本镜像上运行你的脚本。
你需要重新安装 <code>Ruby</code>，还需要在安装 <code>Node</code> 之前，忍受不必要的 82 秒时间，真是痛苦至极。</p>
<p>使用 <code>Docker</code> 的方式</p>
<p>把创建镜像的步骤写入到 <code>Dockerfile</code> 文件中，看懂 <code>Dockerfile</code> 非常容易，因为里面就是你输入的命令，第一次安装 <code>Ruby</code> 不会比其它方式快，但是请看我们再次通过 <code>Dockerfile</code> 创建一个镜像：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>FROM ubuntu:12.04
RUN apt-get update

## MYSQL
RUN apt-get install -y -q mysql-client libmysqlclient-dev

## RUBY
RUN apt-get install -y -q ruby1.9.1 ruby1.9.1-dev rubygems1.9.1 irb1.9.1 build-essential libopenssl-ruby1.9.1 libssl-dev zlib1g-dev
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>root@precise64:/# time docker build -t=&#34;dlite/appserver&#34; .
Uploading context 92160 bytes
Step 1 : FROM ubuntu:12.04
 ---&gt; 8dbd9e392a96
Step 2 : RUN apt-get update
 ---&gt; Using cache
 ---&gt; b55e9ee7b959
Step 3 : RUN apt-get install -y -q mysql-client libmysqlclient-dev
 ---&gt; Using cache
 ---&gt; dc92be6158b0
Step 4 : RUN apt-get install -y -q ruby1.9.1 ruby1.9.1-dev rubygems1.9.1 irb1.9.1 build-essential libopenssl-ruby1.9.1 libssl-dev zlib1g-dev
 ---&gt; Using cache
 ---&gt; 7038022227c0
Successfully built 7038022227c0

real    0m0.848s
</code></pre></div><p>哇哦，为什么安装 <code>Ruby</code> 连一秒都不到？ 看那些 Keys (例如：dc92be6158b0 )，<code>Docker</code> 不会重新运行 <code>Dockerfile</code> 中的每一行命令，会检查那是不是已经运行过的命令，是的话直接从缓存中取回对文件的修改。
做的如此神奇，是因为 <code>Docker</code> 使用了 <code>AuFS</code> 文件系统（union file system）</p>
<p>总之，<code>Docker</code> 让我们反复地创建一个镜像不再那么痛苦，对于已经成功的后面就不需要再等了。I&rsquo;m not perfect and Docker doesn&rsquo;t punish me when I make mistakes.</p>
<h3 id=部署镜像不更新基础设施>部署镜像，不更新基础设施</h3>
<p><img src=2.png alt></p>
<p>传统的做法</p>
<p><a href=https://scoutapp.com/>Scout</a>和其它部署一样，很长的时间在运行虚拟机，使用 <code>Puppet</code> 来更新所有的基础设施，但是经常会非常的痛苦。</p>
<p>如果我们部署更新到我们的栈，<code>Puppet</code> 会在每台虚拟机运行更新，这会花去许多的时间——即使是一个小小的改变，<code>Puppet</code> 需要检查所其它所有的都检查一遍。在部署的时间会出问题：如果我们安装 <code>Memcached</code> 时网络有点问题，<code>apt-get install memcached</code> 就会执行失败。</p>
<p>回滚到主要的改变通过不会像我们想像的那么平稳，（例如更新 <code>Ruby</code> 的版本）
这些总是并不是 <code>Puppet</code> 的问题， <code>Puppet</code> 和 <code>Chef</code> 是一个工具，当你要在一直运行的多台虚拟机上运行命令时，它会给你到多台机器上去运行，可以节省许多时间。</p>
<p><code>Docker</code> 的做法</p>
<p>部署镜像——不修改已经存在的虚拟机，你会 100% 有确定在本地可以运行的，在生产环境也能运行。</p>
<p>镜像非常地大是吗？在 <code>Docker</code> 上不是这样的，请记住容器不会运行在宿主机上，它使用 union file system，当我们改变一个镜像，我们只需要新的一层。（说的好高大上，完全听不懂，后面可以看看 union file system 为何如此强大）</p>
<p>例如，在应用服务器上安装 <code>Memcached</code>，创建一个新的镜像，然后给它打上一个 <code>tag</code> 叫 <code>dlite/appserver-memcached</code>，它是基于 <code>dlite/appserver</code> 这个镜像的，dlite 是我在 index.docker.io 上的用户名。</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>root<span>@</span>precise64:/<span>#</span> time docker build -t=<span style=color:#a31515>&#34;dlite/appserver-memcached&#34;</span> .
Uploading context 92160 bytes
Step 1 : FROM appserver
 ---&gt; 8dbd9e392a96
Step 2 : RUN apt-get update
 ---&gt; Using cache
 ---&gt; b55e9ee7b959
Step 3 : RUN apt-get install -y -q memcached
 ---&gt; Running in 2a2a689daee3
Reading <span style=color:#00f>package</span> lists...
Building dependency tree...
...
Starting memcached: memcached.
Processing triggers <span style=color:#00f>for</span> libc-bin ...
ldconfig deferred processing now taking place
 ---&gt; 2a2a689daee3
Successfully built 2a2a689daee3

real    0m13.289s
user    0m0.132s
sys 0m0.376s
</code></pre></div><p>只用了 13 秒就安装好了 <code>Memcached</code>，<code>Dockerfile</code> 在执行时会优先使用已经安装成功的缓存，这个速度我喜欢。。。</p>
<p>把刚才的操作提交到仓库</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>root@precise64:/# time docker push dlite/appserver-memcached
The push refers to a repository [dlite/appserver-memcached] (len: 1)
Processing checksums
Sending image list
Pushing repository dlite/appserver-memcached (1 tags)
Pushing 8dbd9e392a964056420e5d58ca5cc376ef18e2de93b5cc90e868a1bbc8318c1c
Image 8dbd9e392a964056420e5d58ca5cc376ef18e2de93b5cc90e868a1bbc8318c1c already pushed, skipping
...
Pushing tags for rev [ad8f8a3809afcf0e2cff1af93a8c29275a847609b05b20f7b6d2a5cbd32ff0d8] on {https://registry-1.docker.io/v1/repositories/dlite/appserver-memcached/tags/latest}

real    0m28.710s
</code></pre></div><p>在线上服务器把镜像下载下来</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>root@prod:/# time docker pull dlite/appserver-memcached
Pulling repository dlite/appserver-memcached
Pulling image ad8f8a3809afcf0e2cff1af93a8c29275a847609b05b20f7b6d2a5cbd32ff0d8 (latest) from dlite/appserver-memcached

real    0m15.749s
</code></pre></div><p>只用了 15 秒就把 <code>dlite/appserver-memached</code> 镜像下载下来了，镜像只有 10 MB 它使用 appserver 为基础镜像。</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>root@precise64:~# docker images
REPOSITORY            TAG                 ID                  CREATED             SIZE
appserver             latest              7038022227c0        3 days ago          78.66 MB (virtual 427.9 MB)
appserver-memcached   latest              77dc850dcccc        16 minutes ago      10.19 MB (virtual 438.1 MB)
</code></pre></div><p>我们不需要下载全部的镜像，只需要下载添加 <code>Memcached</code> 的改变就可以了。</p>
<p>大多数情况下，我们的修改非常的小，所以下载一个新的镜像会非常地快。</p>
<p>启动一个新的 <code>Docker</code> 容器很快，上传和下载一个新的镜像也很轻量。</p>
<p>与其在现有的虚拟机上弄的乱七八糟，不如启动一个新的容器，然后把旧的容器删除就好了。</p>
<p>令人情奇的（Mind blown!）
它意味着我们不需要去担心统一性，我们不会去修改现有的虚拟机，只是启动一个新的容器。那也意味着回滚也就是轻而易举的事！<code>Memcached</code> 挂了？直接停止使用 <code>dlite/appserver-memcached</code> 然后启动 <code>dlite/appserver-memcached</code> 的容器就好了。</p>
<h3 id=不足之处>不足之处</h3>
<p>生态还不是很完善，对于分布式配置 / 协调和服务发现没有好的解决方案（那是博文以前，现在应该很不一样了，可参考：《<a href="http://blog.sina.cn/dpool/blog/s/blog_ea790d9d0102w7rw.html?vt=4&wm=3164_0001&tt_group_id=4092136568">腾讯Gaia：万台规模的Docker应用实践</a>）》</p>
<p>我们如何做到新应用服务窗口启动了，自动更改 <code>HAProxy</code> 的 配置文件？</p>
<p>新的数据库容器启动了，应用服务器如何自动与数据库容器通信？</p>
<p>如何让不同主机的 <code>Docker</code> 窗口通信？</p>
<p>即将到来的 Flynn.io 将会解决这些问题，上面的问题将不再是问题（现在这些总是早就不是问题了， Docker 的生态圈已经非常完善，国内 <a href=https://www.daocloud.io/>DaoCloud</a> 在这方面就是领头羊，正在使用它的加速。）</p>
<h3 id=docker-可以像-git-一样部署>Docker 可以像 Git 一样部署</h3>
<p>创建一个项目的时候，开发者可以去使用 <code>Git</code> 来提升性能和灵活性。 <code>Git</code> 鼓励实验新的东西，并且在你做错了不会给你带来很多的麻烦事：在一个分支去做你的实验，如果做遭了，只需要 <code>git rebase</code> 或 <code>git reset</code>， Git 可以很简单地就创建一个分支和推送一个分支。</p>
<p><code>Docker</code> 鼓励实验操作，容器启动非常地快，创建一个镜像更是非常地快，使用别的镜像做为基本镜像也非常的容易，部署更个镜像非常地快，最后但同样重要的是，回滚也非常地方便。</p>
<p>快速 + 灵活 = 部署将会更快乐</p>
</div>
<div class=tags>
<ul class=flat>
<li><a href=/tags/%E7%BF%BB%E8%AF%91>翻译</a></li>
<li><a href=/tags/docker>Docker</a></li>
</ul>
</div></div>
</div>
<div class="footer wrapper">
<nav class=nav>
<div>2024 © Copyright Du, Chengbin | <a href=https://github.com/knadh/hugo-ink>Ink</a> theme on <a href=https://gohugo.io>Hugo</a></div>
</nav>
</div>
<script>feather.replace()</script>
</body>
</html>